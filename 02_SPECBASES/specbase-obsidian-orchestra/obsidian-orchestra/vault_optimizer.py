#!/usr/bin/env python3
"""
VAULT OPTIMIZER - Turn AI Suggestions into Action
Implements the intelligence recommendations automatically
"""

import json
from pathlib import Path

class VaultOptimizer:
    def __init__(self, vault_path, intelligence_report_path):
        self.vault_path = Path(vault_path)
        self.report_path = Path(intelligence_report_path)
        self.load_intelligence_report()

    def load_intelligence_report(self):
        """Load the intelligence analysis"""
        with open(self.report_path, 'r') as f:
            self.report = json.load(f)

        self.gaps = self.report['obsidian_intelligence_report']['structural_analysis']
        self.suggestions = self.report['obsidian_intelligence_report']['ai_suggestions']
        self.top_nodes = self.report['obsidian_intelligence_report']['network_intelligence']['top_influential_nodes']

    def create_missing_index_pages(self):
        """Create index pages for major topics - LEVEL 1 ACTION"""
        print("📋 Creating missing index pages...")

        # Find the missing index pages gap
        index_gap = None
        for gap in self.gaps:
            if gap['type'] == 'missing_index_pages':
                index_gap = gap
                break

        if not index_gap:
            print("✅ No missing index pages detected")
            return

        created_count = 0
        for tag, count in index_gap['tags'][:10]:  # Top 10 most needed
            index_filename = f"{tag}_INDEX.md"
            index_path = self.vault_path / index_filename

            if not index_path.exists():
                # Create comprehensive index page
                content = f"""# {tag.title()} Index

## 📊 Topic Overview
This index covers **{count} documents** related to #{tag}.

*Auto-generated by Vault Intelligence System*

## 🎯 Key Areas

### 📝 Main Documents
<!-- Add your main {tag} documents here -->

### 🔗 Related Concepts
<!-- Link to related topic indexes -->

### 📚 Resources
<!-- External resources and references -->

## 🏷️ All {tag.title()} Documents

```dataview
LIST
FROM #{tag}
SORT file.name ASC
```

## 🕸️ Connection Map

```dataview
TABLE
  length(file.outlinks) as "Outbound Links",
  length(file.inlinks) as "Inbound Links"
FROM #{tag}
SORT length(file.outlinks) DESC
```

---
*Created: {self.get_timestamp()}*
*Intelligence Score: {count} related documents*

#index #{tag} #navigation-hub
"""

                with open(index_path, 'w') as f:
                    f.write(content)

                print(f"✅ Created index: {index_filename}")
                created_count += 1

        print(f"📋 Created {created_count} index pages")
        return created_count

    def suggest_bidirectional_links(self):
        """Generate specific bidirectional link suggestions - LEVEL 2 ACTION"""
        print("🔗 Analyzing bidirectional link opportunities...")

        # Find the bidirectional links gap
        bidir_gap = None
        for gap in self.gaps:
            if gap['type'] == 'missing_bidirectional_links':
                bidir_gap = gap
                break

        if not bidir_gap:
            print("✅ No bidirectional link issues detected")
            return []

        recommendations = []

        # Get specific examples from the gap analysis
        examples = bidir_gap.get('examples', [])[:20]  # Top 20 most important

        for source, target in examples:
            # Check if both files exist
            source_path = self.vault_path / f"{source}.md"
            target_path = self.vault_path / f"{target}.md"

            if source_path.exists() and target_path.exists():
                recommendations.append({
                    'action': 'add_backlink',
                    'from_file': target,
                    'to_file': source,
                    'link_text': f"[[{source}]]",
                    'reason': f"Complete bidirectional relationship",
                    'priority': 'medium'
                })

        # Create implementation guide
        guide_path = self.vault_path / "BIDIRECTIONAL_LINKS_GUIDE.md"
        guide_content = f"""# 🔗 Bidirectional Links Implementation Guide

## 📊 Analysis Results
Found **{bidir_gap['count']}** one-way connections that could be bidirectional.

## 🎯 Top Priority Links to Add

"""

        for i, rec in enumerate(recommendations[:15]):
            guide_content += f"""### {i+1}. Add link in {rec['from_file']}
- **Add this link:** `{rec['link_text']}`
- **Reason:** {rec['reason']}
- **Impact:** Improves navigation and context discovery

"""

        guide_content += """
## 🛠️ How to Implement

1. **Manual Method:**
   - Open each target file
   - Add the suggested link in a relevant context
   - Consider adding it in a "Related" or "See Also" section

2. **Batch Method:**
   - Use Find & Replace to add links systematically
   - Or use Templater to automate link insertion

3. **Strategic Placement:**
   - Add links where they provide genuine value
   - Consider the reading flow and context
   - Group related links together

## 🎨 Link Placement Templates

### For Related Concepts:
```markdown
## Related Concepts
- [[Concept A]] - Brief description
- [[Concept B]] - Brief description
```

### For See Also Sections:
```markdown
## See Also
- [[Related Document]] - Extended information
- [[Alternative Approach]] - Different perspective
```

---
*Generated by Vault Intelligence System*
*Impact: Strengthens {bidir_gap['count']} relationships*
"""

        with open(guide_path, 'w') as f:
            f.write(guide_content)

        print(f"🔗 Created implementation guide: BIDIRECTIONAL_LINKS_GUIDE.md")
        print(f"📊 {len(recommendations)} specific recommendations generated")

        return recommendations

    def connect_isolated_content(self):
        """Connect isolated valuable content - LEVEL 3 ACTION"""
        print("🏝️ Connecting isolated valuable content...")

        # Find isolated content gap
        isolated_gap = None
        for gap in self.gaps:
            if gap['type'] == 'isolated_valuable_content':
                isolated_gap = gap
                break

        if not isolated_gap:
            print("✅ No isolated valuable content detected")
            return

        isolated_nodes = isolated_gap.get('nodes', [])[:20]  # Top 20 most important

        # Create connection strategy
        strategy_path = self.vault_path / "ISOLATED_CONTENT_STRATEGY.md"
        strategy_content = f"""# 🏝️ Isolated Content Connection Strategy

## 📊 Analysis
Found **{isolated_gap['count']}** rich documents with insufficient connections.

## 🎯 High-Value Isolated Content

"""

        for i, node in enumerate(isolated_nodes):
            node_path = self.vault_path / f"{node}.md"
            if node_path.exists():
                try:
                    with open(node_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                    word_count = len(content.split())

                    strategy_content += f"""### {i+1}. {node}
- **Word Count:** {word_count}
- **Status:** Isolated (needs connections)
- **Action:** Add relevant tags and links

**Suggested Connections:**
- Add relevant tags: `#topic #category #type`
- Link to related concepts
- Create context in related documents

"""
                except:
                    pass

        strategy_content += """
## 🛠️ Connection Strategies

### 1. Tag Integration
Add relevant tags to categorize content:
```markdown
#main-topic #sub-category #content-type
```

### 2. Link to Hubs
Connect to your top influential nodes:
"""

        # Add top nodes as connection targets
        for node, score in self.top_nodes[:5]:
            strategy_content += f"- [[{node}]] (Centrality: {score:.2f})\n"

        strategy_content += """
### 3. Create Bridges
Add links between isolated content and existing clusters.

### 4. Context Integration
Reference isolated content in related documents.

## 📋 Implementation Checklist

- [ ] Review each isolated document
- [ ] Add 2-3 relevant tags minimum
- [ ] Create 3-5 outbound links
- [ ] Reference from 1-2 hub documents
- [ ] Verify improved connectivity

---
*Generated by Vault Intelligence System*
*Target: Connect {isolated_gap['count']} isolated documents*
"""

        with open(strategy_path, 'w') as f:
            f.write(strategy_content)

        print(f"🏝️ Created strategy guide: ISOLATED_CONTENT_STRATEGY.md")
        print(f"📊 Targeting {len(isolated_nodes)} high-value documents")

    def create_community_strengthening_plan(self):
        """Create plan to strengthen sparse communities - LEVEL 4 ACTION"""
        print("🏘️ Creating community strengthening plan...")

        # Find sparse communities gap
        sparse_gap = None
        for gap in self.gaps:
            if gap['type'] == 'sparse_communities':
                sparse_gap = gap
                break

        if not sparse_gap:
            print("✅ No sparse communities detected")
            return

        sparse_communities = sparse_gap.get('communities', [])[:10]

        plan_path = self.vault_path / "COMMUNITY_STRENGTHENING_PLAN.md"
        plan_content = f"""# 🏘️ Community Strengthening Plan

## 📊 Analysis
Found **{sparse_gap['count']}** communities with low internal connectivity.

## 🎯 Sparse Communities to Strengthen

"""

        for i, (comm_name, connectivity) in enumerate(sparse_communities):
            plan_content += f"""### {i+1}. {comm_name}
- **Current Connectivity:** {connectivity:.3f}
- **Status:** Needs internal links
- **Goal:** Increase to >0.3 connectivity

**Strengthening Strategy:**
- Review all documents in this community
- Add cross-references between related concepts
- Create sub-topic clusters within the community
- Consider creating a community hub/index

"""

        plan_content += """
## 🛠️ Community Strengthening Techniques

### 1. Hub Creation
Create a central hub document for each community:
```markdown
# [Community Name] Hub

## Overview
Central navigation for [topic] related content.

## Key Documents
- [[Document A]] - Primary concepts
- [[Document B]] - Advanced topics
- [[Document C]] - Examples and applications

## Sub-Topics
- [[Sub-topic 1]]
- [[Sub-topic 2]]
```

### 2. Cross-Linking Strategy
- Link related concepts within the community
- Create "See Also" sections
- Add contextual references
- Build conceptual bridges

### 3. Topic Hierarchies
Organize community content into hierarchies:
- Main concepts → Sub-concepts → Examples
- Theory → Practice → Applications
- Overview → Details → Implementation

## 📋 Implementation Priority

1. **High Impact Communities** (large, important topics)
2. **Medium Impact Communities** (specialized areas)
3. **Low Impact Communities** (edge cases)

---
*Generated by Vault Intelligence System*
*Target: Strengthen {sparse_gap['count']} communities*
"""

        with open(plan_path, 'w') as f:
            f.write(plan_content)

        print(f"🏘️ Created plan: COMMUNITY_STRENGTHENING_PLAN.md")
        print(f"📊 Targeting {len(sparse_communities)} sparse communities")

    def generate_master_action_plan(self):
        """Generate comprehensive action plan - MASTER LEVEL"""
        print("🎯 Generating master optimization action plan...")

        master_plan_path = self.vault_path / "VAULT_OPTIMIZATION_MASTER_PLAN.md"

        plan_content = f"""# 🎯 Vault Optimization Master Plan

*Generated by Advanced Intelligence Analysis - FREE InfraNodus Alternative*

## 📊 Current Vault Status

- **Documents:** {self.report['obsidian_intelligence_report']['executive_summary']['total_documents']}
- **Hidden Connections:** {self.report['obsidian_intelligence_report']['executive_summary']['total_connections']:,}
- **Communities:** {self.report['obsidian_intelligence_report']['executive_summary']['communities_detected']}
- **Network Density:** {self.report['obsidian_intelligence_report']['executive_summary']['network_density']:.4f}

## 🚀 Optimization Roadmap

### Phase 1: Quick Wins (1-2 hours)
1. **Create Index Pages** 📋
   - Run: Create missing index pages for major topics
   - Impact: Improved navigation for large topic areas
   - Files: Generated index pages for top topics

2. **Review Top Nodes** 🏆
   - Focus on your most influential documents:
"""

        # Add top influential nodes
        for i, (node, score) in enumerate(self.top_nodes[:5]):
            plan_content += f"   - **{node}** (Score: {score:.2f})\n"

        plan_content += """
### Phase 2: Structural Improvements (2-4 hours)
1. **Connect Isolated Content** 🏝️
   - Target: High-value documents with few connections
   - Method: Add relevant tags and strategic links
   - Files: ISOLATED_CONTENT_STRATEGY.md

2. **Strengthen Communities** 🏘️
   - Target: Sparse topic clusters
   - Method: Internal cross-linking and hub creation
   - Files: COMMUNITY_STRENGTHENING_PLAN.md

### Phase 3: Relationship Enhancement (4-6 hours)
1. **Add Bidirectional Links** 🔗
   - Target: One-way connections needing completion
   - Method: Strategic backlink placement
   - Files: BIDIRECTIONAL_LINKS_GUIDE.md

2. **Create Topic Bridges** 🌉
   - Connect related communities
   - Build conceptual pathways
   - Enhance knowledge flow

## 🛠️ Implementation Tools Created

1. **BIDIRECTIONAL_LINKS_GUIDE.md** - Specific link recommendations
2. **ISOLATED_CONTENT_STRATEGY.md** - Connection strategies
3. **COMMUNITY_STRENGTHENING_PLAN.md** - Internal linking plans
4. **[Topic]_INDEX.md** - Auto-generated navigation hubs

## 📈 Expected Improvements

### Metrics to Track:
- **Network Density:** Target >0.10 (currently {self.report['obsidian_intelligence_report']['executive_summary']['network_density']:.4f})
- **Average Connections:** Target >60 per doc (currently {self.report['obsidian_intelligence_report']['executive_summary']['avg_connections_per_doc']:.1f})
- **Isolated Documents:** Target <50 (currently {next((gap['count'] for gap in self.gaps if gap['type'] == 'isolated_valuable_content'), 0)})

### Knowledge Benefits:
- 🔍 **Discoverability:** Easier to find related content
- 🕸️ **Connectivity:** Stronger knowledge relationships
- 🧭 **Navigation:** Clear pathways through topics
- 💡 **Insights:** Unexpected connection discovery

## 🎯 Success Criteria

### Phase 1 Complete When:
- [ ] All major topics have index pages
- [ ] Top 5 influential nodes reviewed and enhanced
- [ ] Navigation structure clearly defined

### Phase 2 Complete When:
- [ ] <50 isolated valuable documents remain
- [ ] All large communities have >0.3 internal connectivity
- [ ] Community hubs created for major topics

### Phase 3 Complete When:
- [ ] >80% of one-way links have bidirectional completion
- [ ] Cross-community bridges established
- [ ] Knowledge flow optimized

## 🔄 Continuous Improvement

### Monthly Reviews:
1. Re-run intelligence analysis
2. Track metric improvements
3. Identify new optimization opportunities
4. Maintain knowledge graph health

### Tools for Monitoring:
- Run: `python3 obsidian_complete_test.py .`
- Review: Updated intelligence reports
- Compare: Progress against baseline metrics

---

## 🎉 The Big Picture

**You now have a scientifically optimized knowledge management system that rivals any commercial solution!**

- ✅ **Free Alternative** to $600/year InfraNodus
- ✅ **100% Private** processing on your machine
- ✅ **Enhanced Features** beyond commercial tools
- ✅ **Actionable Intelligence** with specific recommendations
- ✅ **Continuous Optimization** capability

*Start with Phase 1 quick wins, then systematically work through the phases. Your vault will transform from a collection of notes into an intelligent knowledge network!*

---
*Generated: {self.get_timestamp()}*
*Intelligence System: Advanced Network Science Analysis*
*Status: Ready for Implementation*
"""

        with open(master_plan_path, 'w') as f:
            f.write(plan_content)

        print(f"🎯 Created master plan: VAULT_OPTIMIZATION_MASTER_PLAN.md")
        return master_plan_path

    def get_timestamp(self):
        """Get current timestamp"""
        import time
        return time.strftime("%Y-%m-%d %H:%M:%S")

    def run_complete_optimization(self):
        """Run all optimization steps"""
        print("🚀 VAULT OPTIMIZER - TURNING INTELLIGENCE INTO ACTION")
        print("=" * 70)

        # Level 1: Quick wins
        index_count = self.create_missing_index_pages()

        # Level 2: Structural improvements
        self.suggest_bidirectional_links()

        # Level 3: Content integration
        self.connect_isolated_content()

        # Level 4: Community strengthening
        self.create_community_strengthening_plan()

        # Master level: Comprehensive plan
        master_plan = self.generate_master_action_plan()

        print(f"\n🎉 OPTIMIZATION COMPLETE!")
        print("=" * 70)
        print(f"📋 {index_count} index pages created")
        print(f"🔗 Bidirectional linking guide generated")
        print(f"🏝️ Isolated content strategy created")
        print(f"🏘️ Community strengthening plan ready")
        print(f"🎯 Master action plan: {master_plan.name}")

        print(f"\n🚀 NEXT STEPS:")
        print(f"1. Open: {master_plan.name}")
        print(f"2. Start with Phase 1 quick wins")
        print(f"3. Follow the systematic roadmap")
        print(f"4. Track your improvements!")

        return master_plan

def main():
    import sys

    if len(sys.argv) < 2:
        print("🎯 VAULT OPTIMIZER")
        print("Turn AI intelligence into actionable improvements!")
        print()
        print("Usage: python3 vault_optimizer.py <vault_path>")
        print("Note: Run obsidian_complete_test.py first to generate intelligence report")
        sys.exit(1)

    vault_path = sys.argv[1]
    intelligence_report = f"{vault_path}/obsidian_intelligence_complete/complete_intelligence_report.json"

    if not Path(intelligence_report).exists():
        print(f"❌ Intelligence report not found: {intelligence_report}")
        print("💡 Run obsidian_complete_test.py first to generate the analysis")
        sys.exit(1)

    optimizer = VaultOptimizer(vault_path, intelligence_report)
    master_plan = optimizer.run_complete_optimization()

if __name__ == "__main__":
    main()