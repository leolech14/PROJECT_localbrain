#!/usr/bin/env python3
"""
VAULT OPTIMIZER - Turn AI Suggestions into Action
Implements the intelligence recommendations automatically
"""

import json
from pathlib import Path

class VaultOptimizer:
    def __init__(self, vault_path, intelligence_report_path):
        self.vault_path = Path(vault_path)
        self.report_path = Path(intelligence_report_path)
        self.load_intelligence_report()

    def load_intelligence_report(self):
        """Load the intelligence analysis"""
        with open(self.report_path, 'r') as f:
            self.report = json.load(f)

        self.gaps = self.report['obsidian_intelligence_report']['structural_analysis']
        self.suggestions = self.report['obsidian_intelligence_report']['ai_suggestions']
        self.top_nodes = self.report['obsidian_intelligence_report']['network_intelligence']['top_influential_nodes']

    def create_missing_index_pages(self):
        """Create index pages for major topics - LEVEL 1 ACTION"""
        print("ğŸ“‹ Creating missing index pages...")

        # Find the missing index pages gap
        index_gap = None
        for gap in self.gaps:
            if gap['type'] == 'missing_index_pages':
                index_gap = gap
                break

        if not index_gap:
            print("âœ… No missing index pages detected")
            return

        created_count = 0
        for tag, count in index_gap['tags'][:10]:  # Top 10 most needed
            index_filename = f"{tag}_INDEX.md"
            index_path = self.vault_path / index_filename

            if not index_path.exists():
                # Create comprehensive index page
                content = f"""# {tag.title()} Index

## ğŸ“Š Topic Overview
This index covers **{count} documents** related to #{tag}.

*Auto-generated by Vault Intelligence System*

## ğŸ¯ Key Areas

### ğŸ“ Main Documents
<!-- Add your main {tag} documents here -->

### ğŸ”— Related Concepts
<!-- Link to related topic indexes -->

### ğŸ“š Resources
<!-- External resources and references -->

## ğŸ·ï¸ All {tag.title()} Documents

```dataview
LIST
FROM #{tag}
SORT file.name ASC
```

## ğŸ•¸ï¸ Connection Map

```dataview
TABLE
  length(file.outlinks) as "Outbound Links",
  length(file.inlinks) as "Inbound Links"
FROM #{tag}
SORT length(file.outlinks) DESC
```

---
*Created: {self.get_timestamp()}*
*Intelligence Score: {count} related documents*

#index #{tag} #navigation-hub
"""

                with open(index_path, 'w') as f:
                    f.write(content)

                print(f"âœ… Created index: {index_filename}")
                created_count += 1

        print(f"ğŸ“‹ Created {created_count} index pages")
        return created_count

    def suggest_bidirectional_links(self):
        """Generate specific bidirectional link suggestions - LEVEL 2 ACTION"""
        print("ğŸ”— Analyzing bidirectional link opportunities...")

        # Find the bidirectional links gap
        bidir_gap = None
        for gap in self.gaps:
            if gap['type'] == 'missing_bidirectional_links':
                bidir_gap = gap
                break

        if not bidir_gap:
            print("âœ… No bidirectional link issues detected")
            return []

        recommendations = []

        # Get specific examples from the gap analysis
        examples = bidir_gap.get('examples', [])[:20]  # Top 20 most important

        for source, target in examples:
            # Check if both files exist
            source_path = self.vault_path / f"{source}.md"
            target_path = self.vault_path / f"{target}.md"

            if source_path.exists() and target_path.exists():
                recommendations.append({
                    'action': 'add_backlink',
                    'from_file': target,
                    'to_file': source,
                    'link_text': f"[[{source}]]",
                    'reason': f"Complete bidirectional relationship",
                    'priority': 'medium'
                })

        # Create implementation guide
        guide_path = self.vault_path / "BIDIRECTIONAL_LINKS_GUIDE.md"
        guide_content = f"""# ğŸ”— Bidirectional Links Implementation Guide

## ğŸ“Š Analysis Results
Found **{bidir_gap['count']}** one-way connections that could be bidirectional.

## ğŸ¯ Top Priority Links to Add

"""

        for i, rec in enumerate(recommendations[:15]):
            guide_content += f"""### {i+1}. Add link in {rec['from_file']}
- **Add this link:** `{rec['link_text']}`
- **Reason:** {rec['reason']}
- **Impact:** Improves navigation and context discovery

"""

        guide_content += """
## ğŸ› ï¸ How to Implement

1. **Manual Method:**
   - Open each target file
   - Add the suggested link in a relevant context
   - Consider adding it in a "Related" or "See Also" section

2. **Batch Method:**
   - Use Find & Replace to add links systematically
   - Or use Templater to automate link insertion

3. **Strategic Placement:**
   - Add links where they provide genuine value
   - Consider the reading flow and context
   - Group related links together

## ğŸ¨ Link Placement Templates

### For Related Concepts:
```markdown
## Related Concepts
- [[Concept A]] - Brief description
- [[Concept B]] - Brief description
```

### For See Also Sections:
```markdown
## See Also
- [[Related Document]] - Extended information
- [[Alternative Approach]] - Different perspective
```

---
*Generated by Vault Intelligence System*
*Impact: Strengthens {bidir_gap['count']} relationships*
"""

        with open(guide_path, 'w') as f:
            f.write(guide_content)

        print(f"ğŸ”— Created implementation guide: BIDIRECTIONAL_LINKS_GUIDE.md")
        print(f"ğŸ“Š {len(recommendations)} specific recommendations generated")

        return recommendations

    def connect_isolated_content(self):
        """Connect isolated valuable content - LEVEL 3 ACTION"""
        print("ğŸï¸ Connecting isolated valuable content...")

        # Find isolated content gap
        isolated_gap = None
        for gap in self.gaps:
            if gap['type'] == 'isolated_valuable_content':
                isolated_gap = gap
                break

        if not isolated_gap:
            print("âœ… No isolated valuable content detected")
            return

        isolated_nodes = isolated_gap.get('nodes', [])[:20]  # Top 20 most important

        # Create connection strategy
        strategy_path = self.vault_path / "ISOLATED_CONTENT_STRATEGY.md"
        strategy_content = f"""# ğŸï¸ Isolated Content Connection Strategy

## ğŸ“Š Analysis
Found **{isolated_gap['count']}** rich documents with insufficient connections.

## ğŸ¯ High-Value Isolated Content

"""

        for i, node in enumerate(isolated_nodes):
            node_path = self.vault_path / f"{node}.md"
            if node_path.exists():
                try:
                    with open(node_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                    word_count = len(content.split())

                    strategy_content += f"""### {i+1}. {node}
- **Word Count:** {word_count}
- **Status:** Isolated (needs connections)
- **Action:** Add relevant tags and links

**Suggested Connections:**
- Add relevant tags: `#topic #category #type`
- Link to related concepts
- Create context in related documents

"""
                except:
                    pass

        strategy_content += """
## ğŸ› ï¸ Connection Strategies

### 1. Tag Integration
Add relevant tags to categorize content:
```markdown
#main-topic #sub-category #content-type
```

### 2. Link to Hubs
Connect to your top influential nodes:
"""

        # Add top nodes as connection targets
        for node, score in self.top_nodes[:5]:
            strategy_content += f"- [[{node}]] (Centrality: {score:.2f})\n"

        strategy_content += """
### 3. Create Bridges
Add links between isolated content and existing clusters.

### 4. Context Integration
Reference isolated content in related documents.

## ğŸ“‹ Implementation Checklist

- [ ] Review each isolated document
- [ ] Add 2-3 relevant tags minimum
- [ ] Create 3-5 outbound links
- [ ] Reference from 1-2 hub documents
- [ ] Verify improved connectivity

---
*Generated by Vault Intelligence System*
*Target: Connect {isolated_gap['count']} isolated documents*
"""

        with open(strategy_path, 'w') as f:
            f.write(strategy_content)

        print(f"ğŸï¸ Created strategy guide: ISOLATED_CONTENT_STRATEGY.md")
        print(f"ğŸ“Š Targeting {len(isolated_nodes)} high-value documents")

    def create_community_strengthening_plan(self):
        """Create plan to strengthen sparse communities - LEVEL 4 ACTION"""
        print("ğŸ˜ï¸ Creating community strengthening plan...")

        # Find sparse communities gap
        sparse_gap = None
        for gap in self.gaps:
            if gap['type'] == 'sparse_communities':
                sparse_gap = gap
                break

        if not sparse_gap:
            print("âœ… No sparse communities detected")
            return

        sparse_communities = sparse_gap.get('communities', [])[:10]

        plan_path = self.vault_path / "COMMUNITY_STRENGTHENING_PLAN.md"
        plan_content = f"""# ğŸ˜ï¸ Community Strengthening Plan

## ğŸ“Š Analysis
Found **{sparse_gap['count']}** communities with low internal connectivity.

## ğŸ¯ Sparse Communities to Strengthen

"""

        for i, (comm_name, connectivity) in enumerate(sparse_communities):
            plan_content += f"""### {i+1}. {comm_name}
- **Current Connectivity:** {connectivity:.3f}
- **Status:** Needs internal links
- **Goal:** Increase to >0.3 connectivity

**Strengthening Strategy:**
- Review all documents in this community
- Add cross-references between related concepts
- Create sub-topic clusters within the community
- Consider creating a community hub/index

"""

        plan_content += """
## ğŸ› ï¸ Community Strengthening Techniques

### 1. Hub Creation
Create a central hub document for each community:
```markdown
# [Community Name] Hub

## Overview
Central navigation for [topic] related content.

## Key Documents
- [[Document A]] - Primary concepts
- [[Document B]] - Advanced topics
- [[Document C]] - Examples and applications

## Sub-Topics
- [[Sub-topic 1]]
- [[Sub-topic 2]]
```

### 2. Cross-Linking Strategy
- Link related concepts within the community
- Create "See Also" sections
- Add contextual references
- Build conceptual bridges

### 3. Topic Hierarchies
Organize community content into hierarchies:
- Main concepts â†’ Sub-concepts â†’ Examples
- Theory â†’ Practice â†’ Applications
- Overview â†’ Details â†’ Implementation

## ğŸ“‹ Implementation Priority

1. **High Impact Communities** (large, important topics)
2. **Medium Impact Communities** (specialized areas)
3. **Low Impact Communities** (edge cases)

---
*Generated by Vault Intelligence System*
*Target: Strengthen {sparse_gap['count']} communities*
"""

        with open(plan_path, 'w') as f:
            f.write(plan_content)

        print(f"ğŸ˜ï¸ Created plan: COMMUNITY_STRENGTHENING_PLAN.md")
        print(f"ğŸ“Š Targeting {len(sparse_communities)} sparse communities")

    def generate_master_action_plan(self):
        """Generate comprehensive action plan - MASTER LEVEL"""
        print("ğŸ¯ Generating master optimization action plan...")

        master_plan_path = self.vault_path / "VAULT_OPTIMIZATION_MASTER_PLAN.md"

        plan_content = f"""# ğŸ¯ Vault Optimization Master Plan

*Generated by Advanced Intelligence Analysis - FREE InfraNodus Alternative*

## ğŸ“Š Current Vault Status

- **Documents:** {self.report['obsidian_intelligence_report']['executive_summary']['total_documents']}
- **Hidden Connections:** {self.report['obsidian_intelligence_report']['executive_summary']['total_connections']:,}
- **Communities:** {self.report['obsidian_intelligence_report']['executive_summary']['communities_detected']}
- **Network Density:** {self.report['obsidian_intelligence_report']['executive_summary']['network_density']:.4f}

## ğŸš€ Optimization Roadmap

### Phase 1: Quick Wins (1-2 hours)
1. **Create Index Pages** ğŸ“‹
   - Run: Create missing index pages for major topics
   - Impact: Improved navigation for large topic areas
   - Files: Generated index pages for top topics

2. **Review Top Nodes** ğŸ†
   - Focus on your most influential documents:
"""

        # Add top influential nodes
        for i, (node, score) in enumerate(self.top_nodes[:5]):
            plan_content += f"   - **{node}** (Score: {score:.2f})\n"

        plan_content += """
### Phase 2: Structural Improvements (2-4 hours)
1. **Connect Isolated Content** ğŸï¸
   - Target: High-value documents with few connections
   - Method: Add relevant tags and strategic links
   - Files: ISOLATED_CONTENT_STRATEGY.md

2. **Strengthen Communities** ğŸ˜ï¸
   - Target: Sparse topic clusters
   - Method: Internal cross-linking and hub creation
   - Files: COMMUNITY_STRENGTHENING_PLAN.md

### Phase 3: Relationship Enhancement (4-6 hours)
1. **Add Bidirectional Links** ğŸ”—
   - Target: One-way connections needing completion
   - Method: Strategic backlink placement
   - Files: BIDIRECTIONAL_LINKS_GUIDE.md

2. **Create Topic Bridges** ğŸŒ‰
   - Connect related communities
   - Build conceptual pathways
   - Enhance knowledge flow

## ğŸ› ï¸ Implementation Tools Created

1. **BIDIRECTIONAL_LINKS_GUIDE.md** - Specific link recommendations
2. **ISOLATED_CONTENT_STRATEGY.md** - Connection strategies
3. **COMMUNITY_STRENGTHENING_PLAN.md** - Internal linking plans
4. **[Topic]_INDEX.md** - Auto-generated navigation hubs

## ğŸ“ˆ Expected Improvements

### Metrics to Track:
- **Network Density:** Target >0.10 (currently {self.report['obsidian_intelligence_report']['executive_summary']['network_density']:.4f})
- **Average Connections:** Target >60 per doc (currently {self.report['obsidian_intelligence_report']['executive_summary']['avg_connections_per_doc']:.1f})
- **Isolated Documents:** Target <50 (currently {next((gap['count'] for gap in self.gaps if gap['type'] == 'isolated_valuable_content'), 0)})

### Knowledge Benefits:
- ğŸ” **Discoverability:** Easier to find related content
- ğŸ•¸ï¸ **Connectivity:** Stronger knowledge relationships
- ğŸ§­ **Navigation:** Clear pathways through topics
- ğŸ’¡ **Insights:** Unexpected connection discovery

## ğŸ¯ Success Criteria

### Phase 1 Complete When:
- [ ] All major topics have index pages
- [ ] Top 5 influential nodes reviewed and enhanced
- [ ] Navigation structure clearly defined

### Phase 2 Complete When:
- [ ] <50 isolated valuable documents remain
- [ ] All large communities have >0.3 internal connectivity
- [ ] Community hubs created for major topics

### Phase 3 Complete When:
- [ ] >80% of one-way links have bidirectional completion
- [ ] Cross-community bridges established
- [ ] Knowledge flow optimized

## ğŸ”„ Continuous Improvement

### Monthly Reviews:
1. Re-run intelligence analysis
2. Track metric improvements
3. Identify new optimization opportunities
4. Maintain knowledge graph health

### Tools for Monitoring:
- Run: `python3 obsidian_complete_test.py .`
- Review: Updated intelligence reports
- Compare: Progress against baseline metrics

---

## ğŸ‰ The Big Picture

**You now have a scientifically optimized knowledge management system that rivals any commercial solution!**

- âœ… **Free Alternative** to $600/year InfraNodus
- âœ… **100% Private** processing on your machine
- âœ… **Enhanced Features** beyond commercial tools
- âœ… **Actionable Intelligence** with specific recommendations
- âœ… **Continuous Optimization** capability

*Start with Phase 1 quick wins, then systematically work through the phases. Your vault will transform from a collection of notes into an intelligent knowledge network!*

---
*Generated: {self.get_timestamp()}*
*Intelligence System: Advanced Network Science Analysis*
*Status: Ready for Implementation*
"""

        with open(master_plan_path, 'w') as f:
            f.write(plan_content)

        print(f"ğŸ¯ Created master plan: VAULT_OPTIMIZATION_MASTER_PLAN.md")
        return master_plan_path

    def get_timestamp(self):
        """Get current timestamp"""
        import time
        return time.strftime("%Y-%m-%d %H:%M:%S")

    def run_complete_optimization(self):
        """Run all optimization steps"""
        print("ğŸš€ VAULT OPTIMIZER - TURNING INTELLIGENCE INTO ACTION")
        print("=" * 70)

        # Level 1: Quick wins
        index_count = self.create_missing_index_pages()

        # Level 2: Structural improvements
        self.suggest_bidirectional_links()

        # Level 3: Content integration
        self.connect_isolated_content()

        # Level 4: Community strengthening
        self.create_community_strengthening_plan()

        # Master level: Comprehensive plan
        master_plan = self.generate_master_action_plan()

        print(f"\nğŸ‰ OPTIMIZATION COMPLETE!")
        print("=" * 70)
        print(f"ğŸ“‹ {index_count} index pages created")
        print(f"ğŸ”— Bidirectional linking guide generated")
        print(f"ğŸï¸ Isolated content strategy created")
        print(f"ğŸ˜ï¸ Community strengthening plan ready")
        print(f"ğŸ¯ Master action plan: {master_plan.name}")

        print(f"\nğŸš€ NEXT STEPS:")
        print(f"1. Open: {master_plan.name}")
        print(f"2. Start with Phase 1 quick wins")
        print(f"3. Follow the systematic roadmap")
        print(f"4. Track your improvements!")

        return master_plan

def main():
    import sys

    if len(sys.argv) < 2:
        print("ğŸ¯ VAULT OPTIMIZER")
        print("Turn AI intelligence into actionable improvements!")
        print()
        print("Usage: python3 vault_optimizer.py <vault_path>")
        print("Note: Run obsidian_complete_test.py first to generate intelligence report")
        sys.exit(1)

    vault_path = sys.argv[1]
    intelligence_report = f"{vault_path}/obsidian_intelligence_complete/complete_intelligence_report.json"

    if not Path(intelligence_report).exists():
        print(f"âŒ Intelligence report not found: {intelligence_report}")
        print("ğŸ’¡ Run obsidian_complete_test.py first to generate the analysis")
        sys.exit(1)

    optimizer = VaultOptimizer(vault_path, intelligence_report)
    master_plan = optimizer.run_complete_optimization()

if __name__ == "__main__":
    main()